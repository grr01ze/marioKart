<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Mario kart</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #loadingMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            background-color: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 10px;
            display: block;
        }
        #errorMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-family: Arial, sans-serif;
            font-size: 18px;
            background-color: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="loadingMessage">Chargement du jeu...</div>
    <div id="errorMessage"></div>
    
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        let camera, scene, renderer;
        let kart;
        let moveForward = false;
        let moveBackward = false;
        let turnLeft = false;
        let turnRight = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let speed = 0;
        let drift = false;
        let onGround = false;
        let gravity = -0.05;
        const collisionObjects = [];
        
        let loadingElement = document.getElementById('loadingMessage');
        let errorElement = document.getElementById('errorMessage');
        
        // Vérifier la compatibilité WebGL
        if (checkWebGLCompatibility()) {
            init();
            animate();
        }
        
        function checkWebGLCompatibility() {
            if (!window.WebGLRenderingContext) {
                showError("Votre navigateur ne semble pas prendre en charge WebGL.");
                return false;
            }
            
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) {
                    showError("WebGL n'a pas pu être initialisé.");
                    return false;
                }
                return true;
            } catch (e) {
                showError("Erreur lors de l'initialisation de WebGL: " + e.message);
                return false;
            }
        }
        
        function showError(message) {
            errorElement.innerHTML = message;
            errorElement.style.display = 'block';
            loadingElement.style.display = 'none';
            console.error(message);
        }
        
        function init() {
            // Scène
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            
            // Caméra
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, -10);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // Lumières
            const ambientLight = new THREE.AmbientLight(0x404040, 1);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 10, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Sol temporaire
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x00aa00 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            scene.add(ground);
            collisionObjects.push(ground);
            
            // Kart
            const geometry = new THREE.BoxGeometry(1, 0.5, 2);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            kart = new THREE.Mesh(geometry, material);
            kart.position.y = 1;
            scene.add(kart);
            
            // Chargement du modèle 3D (map .glb)
            loadMap();
            
            // Contrôles
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Gestion du redimensionnement
            window.addEventListener('resize', onWindowResize);
            
            // Masquer le message de chargement une fois l'initialisation terminée
            loadingElement.style.display = 'none';
        }
        
        function loadMap() {
            const loader = new GLTFLoader();
            
            loader.load(
                'scene.glb',  // Remplacer par le bon chemin de ton fichier GLB
                function(gltf) {
                    console.log('Modèle chargé avec succès');
                    const mapModel = gltf.scene;
                    mapModel.traverse(function(child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            collisionObjects.push(child);
                        }
                    });
                    scene.add(mapModel);
                },
                function(xhr) {
                    const percent = xhr.loaded / xhr.total * 100;
                    console.log(percent + '% chargé');
                    loadingElement.innerHTML = `Chargement: ${Math.round(percent)}%`;
                },
                function(error) {
                    console.error('Erreur lors du chargement du modèle:', error);
                    loadingElement.style.display = 'none';
                    showError("Erreur lors du chargement du modèle.");
                }
            );
        }
        
        function onKeyDown(event) {
            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'a':
                    turnLeft = true;
                    break;
                case 'ArrowDown':
                case 's':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'd':
                    turnRight = true;
                    break;
                case ' ':
                    drift = true;
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'a':
                    turnLeft = false;
                    break;
                case 'ArrowDown':
                case 's':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'd':
                    turnRight = false;
                    break;
                case ' ':
                    drift = false;
                    break;
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function handleInput() {
            const rotationSpeed = 0.05;
            const acceleration = 0.02;
            const maxSpeed = 0.5;
            
            if (moveForward) {
                speed = Math.min(speed + acceleration, maxSpeed);
            } else if (moveBackward) {
                speed = Math.max(speed - acceleration, -maxSpeed / 2);
            } else {
                speed *= 0.98;
            }
            
            if (turnLeft) {
                kart.rotation.y += rotationSpeed * (drift ? 1.5 : 1);
            }
            if (turnRight) {
                kart.rotation.y -= rotationSpeed * (drift ? 1.5 : 1);
            }
            
            direction.set(
                -Math.sin(kart.rotation.y),
                0,
                -Math.cos(kart.rotation.y)
            ).normalize();
            
            kart.position.add(direction.clone().multiplyScalar(speed));
        }
        
        function animate() {
            requestAnimationFrame(animate);
            handleInput();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
